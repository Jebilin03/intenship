// ================== CONFIGURATION ==================

// Initialize global tracking of processed invitations
if (typeof window.processedInvitations === 'undefined') {
    window.processedInvitations = new Set();
}

// Initialize counters for processed, accepted, and rejected invitations
if (typeof window.invitationCounters === 'undefined') {
    window.invitationCounters = {
        processed: 0,
        accepted: 0,
        rejected: 0
    };
}

// ================== HELPER FUNCTIONS ==================
function getCurrentDateTime() {
    return new Date().toLocaleString();
}

// Load the live log script
function loadLiveLogScript() {
    return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = chrome.runtime.getURL('livelog.js');
        script.onload = () => resolve();
        script.onerror = () => reject(new Error('Failed to load live log script'));
        document.body.appendChild(script);
    });
}

// Adding missing debugLog function
function debugLog(message, type = 'info') {
    const types = {
        info: 'color: #0073e6',
        success: 'color: #2e8b57',
        warning: 'color: #ff9900',
        error: 'color: #d9534f',
        processing: 'color: #9932cc'
    };
    
    console.log(`%c[${getCurrentDateTime()}] ${message}`, types[type] || types.info);
    // Update LiveLog if it's available
    if (typeof window.updateLiveLog === 'function') {
        // Map log types to LiveLog states
        const liveLogState = {
            'info': 'processing',
            'success': 'success',
            'warning': 'waiting',
            'error': 'error',
            'processing': 'processing'
        };
        window.updateLiveLog(message, liveLogState[type] || 'processing');
    }
}

async function loadCriteria() {
    return new Promise((resolve) => {
        chrome.storage.local.get(['criteria'], function(result) {
            if (result.criteria) {
                resolve(result.criteria);
            } else {
                // Default criteria if none saved
                resolve({
                    relevantTitles: ['Data Analyst', 'Software Engineer', 'Developer', 'student', 'python'],
                    relevantInstitutions: ['wcc', 'sdnb'],
                    minMutualConnections: 0,
                    batchLimit: 10,
                    testingMode: false // Added missing testingMode default
                });
            }
        });
    });
}

async function scrollLikeHuman() {
    return new Promise((resolve) => {
        const scrollStep = 200; // Scroll distance per step
        const scrollDelay = 800; // Delay between scrolls
        const scrollCount = 3; // Number of dummy scrolls to perform

        let currentScroll = 0;

        const scrollInterval = setInterval(() => {
            window.scrollBy(0, scrollStep);
            currentScroll++;

            if (currentScroll >= scrollCount) {
                clearInterval(scrollInterval);
                resolve();
            }
        }, scrollDelay);
    });
}

async function extractLinkedInInvitations(batchLimit) {
    const invitationCards = Array.from(document.querySelectorAll('.display-flex.flex-1.align-items-center.pl0'));
    let invitations = {};

    const unprocessedCards = invitationCards.filter(card => {
        const nameElement = card.querySelector('.invitation-card__tvm-title strong');
        const name = nameElement?.innerText.trim() || 'Name not found';
        return !window.processedInvitations.has(name);
    });

    const cardsToProcess = unprocessedCards.slice(0, batchLimit);

    cardsToProcess.forEach((card, index) => {
        const nameElement = card.querySelector('.invitation-card__tvm-title strong');
        const subtitleElement = card.querySelector('.invitation-card__subtitle');
        const mutualConnectionsElement = card.querySelector('.member-insights span');
        const timestampElement = card.querySelector('.time-badge');

        const name = nameElement?.innerText.trim() || 'Name not found';

        invitations[`invitation${index + 1}`] = {
            name: name,
            subtitle: subtitleElement?.innerText.trim() || 'Subtitle not found',
            mutualConnections: mutualConnectionsElement?.innerText.trim() || 'Mutual connections not found',
            timestamp: timestampElement?.innerText.trim() || 'Timestamp not found',
            status: 'pending', 
            reason: '' 
        };

        window.processedInvitations.add(name);
    });

    return invitations;
}
function createOrUpdatePopup() {
    let popup = document.getElementById('invitation-stats-popup');
    if (!popup) {
        // Create the popup if it doesn't exist
        popup = document.createElement('div');
        popup.id = 'invitation-stats-popup';
        popup.style.position = 'fixed';
        popup.style.top = '20px'; // Position at the top
        popup.style.right = '20px'; // Position on the right
        popup.style.backgroundColor = '#f0f8ff'; // Light blue background
        popup.style.border = '1.5px solid rgb(0, 51, 204)'; // Blue border
        popup.style.borderRadius = '10px'; // Rounded corners
        popup.style.padding = '15px 20px'; // Padding for spacing
        popup.style.boxShadow = '0 4px 15px rgba(0, 0, 0, 0.2)'; // Subtle shadow
        popup.style.zIndex = '10000'; // Ensure it's on top
        popup.style.fontFamily = 'Arial, sans-serif';
        popup.style.fontSize = '16px'; // Increased font size
        popup.style.color = '#333'; // Dark text color
        popup.style.display = 'flex';
        popup.style.flexDirection = 'column';
        popup.style.gap = '10px'; // Spacing between items
        popup.style.maxWidth = '230px';
        document.body.appendChild(popup);

        // Add drag functionality
        let isDragging = false;
        let offsetX = 0;
        let offsetY = 0;

        popup.addEventListener('mousedown', (e) => {
            isDragging = true;
            offsetX = e.clientX - popup.getBoundingClientRect().left;
            offsetY = e.clientY - popup.getBoundingClientRect().top;
            popup.style.cursor = 'grabbing';
        });

        document.addEventListener('mousemove', (e) => {
            if (isDragging) {
                e.preventDefault();
                const x = e.clientX - offsetX;
                const y = e.clientY - offsetY;
                popup.style.left = `${x}px`;
                popup.style.top = `${y}px`;
                popup.style.right = 'auto'; // Allow free dragging
            }
        });

        document.addEventListener('mouseup', () => {
            isDragging = false;
            popup.style.cursor = 'grab';
        });

        // Optional: change cursor on hover
        popup.addEventListener('mouseover', () => {
            popup.style.cursor = 'grab';
        });
    }

    // Extract total invitation count from the "All (X)" text
    let totalInvitations = window.totalInvitationCount || 0;

    // Try to update the total count from the HTML if available
    const allCountElement = document.querySelector('.artdeco-pill__text');
    if (allCountElement) {
        const countText = allCountElement.textContent.trim();
        const match = countText.match(/All \((\d+)\)/);
        if (match && match[1]) {
            totalInvitations = parseInt(match[1], 10);
            // Update the stored value
            window.totalInvitationCount = totalInvitations;
        }
    }

    // Calculate pending invitations (total - processed)
    const pendingCount = Math.max(0, totalInvitations - window.invitationCounters.processed);

    // Update the popup content
    popup.innerHTML = `
    <div style="font-size: 18px; font-weight: bold; color: #0073e6; margin-bottom: 10px;">Invitation Status</div>

    <div style="display: flex; align-items: center; gap: 8px;">
        <svg width="18" height="18" fill="#0073e6" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M3 12l18-12v24z"/>
        </svg>
        <strong style="color: #0073e6;">Processed:</strong>
        <span style="color: #0073e6;">${window.invitationCounters.processed}</span>
    </div>

    <div style="display: flex; align-items: center; gap: 8px;">
        <svg width="18" height="18" fill="green" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20">
            <path d="M10 18l-6-6 1.4-1.4L10 15.2l9.6-9.6L21 7l-11 11z"/>
        </svg>
        <strong style="color: #2e8b57;">Accepted:</strong>
        <span style="color: #2e8b57;">${window.invitationCounters.accepted}</span>
    </div>

    <div style="display: flex; align-items: center; gap: 8px;">
        <svg width="18" height="18" fill="red" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M18.3 5.71L12 12l6.29 6.29-1.42 1.42L12 14.83l-6.29 6.29-1.42-1.42L10.59 12 4.29 5.71 5.71 4.29 12 10.59l6.29-6.3z"/>
        </svg>
        <strong style="color: #d9534f;">Rejected:</strong>
        <span style="color: #d9534f;">${window.invitationCounters.rejected}</span>
    </div>

    <div style="display: flex; align-items: center; gap: 8px;">
        <svg width="18" height="18" fill="orange" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M12 22C6.477 22 2 17.523 2 12S6.477 2 12 2s10 4.477 10 10-4.477 10-10 10zm0-3a7 7 0 100-14 7 7 0 000 14zm-1-6h2v5h-2v-5zm0-4h2v2h-2V9z"/>
        </svg>
        <strong style="color: #ff9900;">Pending:</strong>
        <span style="color: #ff9900;">${pendingCount}</span>
    </div>

    <div style="margin-top: 10px; font-size: 14px; color: #666; font-style: italic;">
        Click "Start Processing" to handle the next batch of invitations.
    </div>
    `;
}

async function processInvitationsWithCriteria(invitations) {
    updateLiveLog("⚙️Starting to process invitations with criteria...", "processing");
    debugLog('Starting to process invitations with criteria...', 'processing');
    const batchToProcess = Object.values(invitations);
    const acceptedNames = [];

    for (const invitation of batchToProcess) {
        // Add initial delay
        await new Promise(resolve => setTimeout(resolve, 2000));
        const mutualCount = parseInt(invitation.mutualConnections.match(/\d+/)?.[0] || '0');
        const subtitle = invitation.subtitle; 
        updateLiveLog(`Processing invitation from: ${invitation.name}`, "processing");
        debugLog(`Processing invitation from: ${invitation.name}`, 'processing');
        debugLog(`Title: ${subtitle}\nMutual Connections: ${mutualCount}`, 'info');

        const criteria = await loadCriteria();
        const { relevantTitles, relevantInstitutions, minMutualConnections, testingMode } = criteria;

        const hasSufficientMutualConnections = mutualCount >= minMutualConnections;
        const hasRelevantTitle = relevantTitles.some(title => new RegExp(title, 'i').test(subtitle));
        const hasRelevantInstitution = relevantInstitutions.some(inst => new RegExp(inst, 'i').test(subtitle));

        let reason = '';
        if (hasSufficientMutualConnections) reason += `Mutual connections: ${mutualCount}`;
        if (hasRelevantTitle) reason += `${reason ? ', ' : ''}Relevant title found`;
        if (hasRelevantInstitution) reason += `${reason ? ', ' : ''}Relevant institution found`;

        if (hasSufficientMutualConnections || hasRelevantTitle || hasRelevantInstitution) {
            try {
                if (testingMode) {
                    invitation.status = 'accepted (simulated)';
                    invitation.reason = `${reason} (testing mode)`; // Fixed typo in "testing mode"
                    updateLiveLog(`Simulated accepting invitation from ${invitation.name} (TESTING MODE)`, "success");
                    debugLog(`Simulated accepting invitation from ${invitation.name} (TESTING MODE)`, 'success');
                    
                    // Add to accepted names for simulated accepts too
                    acceptedNames.push({ name: invitation.name, reason: reason });
                } else {
                    const acceptButton = document.querySelector(`button[aria-label*="Accept ${invitation.name}"]`);
                    if (acceptButton) {
                        acceptButton.click();
                        invitation.status = 'accepted';
                        invitation.reason = reason;
                        updateLiveLog(`Accepted invitation from ${invitation.name}`, "success");

                        debugLog(`Accepted invitation from ${invitation.name}`, 'success');
                        
                        acceptedNames.push({ name: invitation.name, reason: reason });

                        // Add longer delay after clicking to ensure page updates
                        await new Promise((resolve) => setTimeout(resolve, 2000 + Math.random() * 2000));

                        // Run the highlighting method after accepting
                        highlightAcceptedInvitationsPostAccept([{ name: invitation.name, reason: reason }]);
                    } else {
                        invitation.status = 'waiting';
                        invitation.reason = 'Accept button not found';
                        debugLog(`Could not find accept button for ${invitation.name}`, 'warning');
                    }
                }
            } catch (error) {
                invitation.status = 'waiting';
                invitation.reason = `Error: ${error.message}`;
                debugLog(`Error processing invitation from ${invitation.name}: ${error.message}`, 'error');
            }
        } else {
            invitation.status = 'rejected';
            invitation.reason = `Does not meet criteria (Mutual connections: ${mutualCount})`;
            debugLog(`Rejected invitation from ${invitation.name}: ${invitation.reason}`, 'warning');
        }

        // Update counters
        window.invitationCounters.processed++;
        if (invitation.status === 'accepted' || invitation.status === 'accepted (simulated)') {
            window.invitationCounters.accepted++;
        } else if (invitation.status === 'rejected') {
            window.invitationCounters.rejected++;
        }

        // Update the popup
        createOrUpdatePopup();

        // Add small delay between processing invitations
        await new Promise(resolve => setTimeout(resolve, 500));
        
        debugLog(`Invitation Object for ${invitation.name}:`, 'info');
        console.log(invitation); // Separated log for better debugging
    }

    // Call the highlighting function for all accepted invitations
    highlightAcceptedInvitations(acceptedNames);

    // AFTER processing all invitations but BEFORE return statement:
    try {
        debugLog('Sending processed invitations to background script...', 'info');
        const response = await new Promise((resolve) => {
            chrome.runtime.sendMessage({
                action: "saveConnectionRequest",
                data: invitations  // This contains all processed invitations
            }, (response) => {
                resolve(response);
            });
        });

        if (response?.success) {
            debugLog('Successfully saved connection requests to database', 'success');
        } else {
            debugLog(`Failed to save: ${response?.error || 'Unknown error'}`, 'error');
        }
    } catch (error) {
        debugLog(`Error sending to background: ${error.message}`, 'error');
    }
    
    return acceptedNames;
}

function highlightAcceptedInvitations(acceptedInvitations) {
    if (!acceptedInvitations || acceptedInvitations.length === 0) {
        debugLog('No accepted invitations to highlight', 'info');
        return;
    }
    
    debugLog('Highlighting accepted invitations...', 'processing');

    const invitationCards = Array.from(document.querySelectorAll('.display-flex.flex-1.align-items-center.pl0'));

    // Function to open in new background tab with delay
    const openInBackgroundTab = (url, name, index) => {
        setTimeout(() => {
            try {
                const a = document.createElement('a');
                a.href = url;
                a.target = '_blank';
                a.rel = 'noopener';
                
                // Create and dispatch mouse event (simulates right-click + "Open in New Tab")
                const evt = new MouseEvent('click', {
                    bubbles: true,
                    cancelable: true,
                    view: window,
                    ctrlKey: true  // Ctrl+Click opens in new tab without switching to it
                });
                a.dispatchEvent(evt);
                debugLog(`Opened profile of ${name} in background tab (${index + 1}/${acceptedInvitations.length}).`, 'success');
            } catch (error) {
                debugLog(`Error opening profile of ${name}: ${error.message}`, 'error');
            }
        }, (index + 1) * 1500); // Increased delay to 1.5 seconds between tabs
    };

    let foundCount = 0;
    acceptedInvitations.forEach(({ name, reason }, index) => {
        const acceptedCard = invitationCards.find(card => {
            const nameElement = card.querySelector('.invitation-card__tvm-title strong');
            return nameElement?.innerText.trim() === name;
        });

        if (acceptedCard) {
            foundCount++;
            // Style the card
            acceptedCard.style.border = '2px solid blue';
            acceptedCard.style.borderRadius = '8px';
            acceptedCard.style.padding = '8px';
            acceptedCard.style.marginBottom = '8px';
            acceptedCard.style.position = 'relative';

            // Create the icon container with both checkmark and open link icons
            const iconContainer = document.createElement('div');
            iconContainer.style.position = 'absolute';
            iconContainer.style.right = '10px';
            iconContainer.style.top = '80px';
            iconContainer.style.transform = 'translateY(-50%)';
            iconContainer.style.display = 'flex';
            iconContainer.style.gap = '10px';
            iconContainer.style.alignItems = 'center';

            // Checkmark icon
            const checkIcon = document.createElement('span');
            checkIcon.innerHTML = '✅';
            checkIcon.style.fontSize = '20px';
            checkIcon.style.cursor = 'help';
            checkIcon.title = `Accepted: ${reason}`;

            // Open in new tab icon
            const openIcon = document.createElement('span');
            openIcon.innerHTML = '🔗';
            openIcon.style.fontSize = '20px';
            openIcon.style.cursor = 'pointer';
            openIcon.title = 'Open profile in new tab';

            // Add click handler for opening in new tab
            openIcon.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                const profileLink = acceptedCard.querySelector('a');
                if (profileLink) {
                    openInBackgroundTab(profileLink.href, name, 0); // Open immediately on click
                } else {
                    debugLog(`Could not find profile link for ${name}`, 'warning');
                }
            });

            // Add icons to container
            iconContainer.appendChild(checkIcon);
            iconContainer.appendChild(openIcon);

            // Add container to card - check if it's already been added
            if (!acceptedCard.querySelector('[data-highlighted="true"]')) {
                iconContainer.setAttribute('data-highlighted', 'true');
                acceptedCard.appendChild(iconContainer);
            }

            debugLog(`Highlighted invitation from ${name}`, 'success');

            // Automatically open profile in background tab
            const profileLink = acceptedCard.querySelector('a');
            if (profileLink) {
                openInBackgroundTab(profileLink.href, name, index);
            } else {
                debugLog(`Could not find profile link for ${name}`, 'warning');
            }
        }
    });

    debugLog(`Found and highlighted ${foundCount} of ${acceptedInvitations.length} accepted invitations.`, 'info');
    if (foundCount > 0) {
        debugLog(`Opening ${foundCount} profiles in background tabs...`, 'processing');
    }
    debugLog('Highlighting complete.', 'success');
}

function highlightAcceptedInvitationsPostAccept(acceptedInvitations) {
    if (!acceptedInvitations || acceptedInvitations.length === 0) {
        debugLog('No accepted invitations to highlight post-accept', 'info');
        return;
    }
    
    debugLog('Highlighting accepted invitations after connection...', 'processing');

    // Function to open in new background tab with delay
    const openInBackgroundTab = (url, name, index) => {
        setTimeout(() => {
            try {
                const a = document.createElement('a');
                a.href = url;
                a.target = '_blank';
                a.rel = 'noopener';
                
                // Create and dispatch mouse event (simulates right-click + "Open in New Tab")
                const evt = new MouseEvent('click', {
                    bubbles: true,
                    cancelable: true,
                    view: window,
                    ctrlKey: true  // Ctrl+Click opens in new tab without switching to it
                });
                a.dispatchEvent(evt);
                debugLog(`Opened profile of ${name} in background tab (${index + 1}/${acceptedInvitations.length}).`, 'success');
            } catch (error) {
                debugLog(`Error opening profile in background tab: ${error.message}`, 'error');
            }
        }, (index + 1) * 1500); // Increased delay to 1.5 seconds between tabs
    };

    // Try both selectors to find all confirmation cards
    const allCards = [
        ...Array.from(document.querySelectorAll('.invitation-card__inline-confirmation')),
        ...Array.from(document.querySelectorAll('.display-flex.flex-1.align-items-center'))
    ];
    
    debugLog(`Found ${allCards.length} total cards to check.`, 'info');
    
    let foundCount = 0;
    acceptedInvitations.forEach(({ name, reason }, index) => {
        // Try multiple approaches to find the card
        let acceptedCard = null;
        
        // Method 1: Try finding by text content
        for (const card of allCards) {
            if (card.textContent.includes(name) || 
                card.textContent.includes(name.split(' ')[0]) ||
                card.textContent.includes(`${name.split(' ')[0]} is now a connection`)) {
                acceptedCard = card;
                break;
            }
        }
        
        if (!acceptedCard) {
            debugLog(`Could not find post-accept card for ${name}`, 'warning');
            return;
        }
        
        foundCount++;
        
        // Style the card
        acceptedCard.style.border = '2px solid green';
        acceptedCard.style.borderRadius = '8px';
        acceptedCard.style.padding = '8px';
        acceptedCard.style.marginBottom = '8px';
        acceptedCard.style.position = 'relative';

        // Remove existing highlighted elements if any
        const existingHighlight = acceptedCard.querySelector('[data-highlighted="true"]');
        if (existingHighlight) {
            existingHighlight.remove();
        }

        // Create the icon container
        const iconContainer = document.createElement('div');
        iconContainer.setAttribute('data-highlighted', 'true');
        iconContainer.style.position = 'absolute';
        iconContainer.style.right = '10px';
        iconContainer.style.top = '50%';
        iconContainer.style.transform = 'translateY(-50%)';
        iconContainer.style.display = 'flex';
        iconContainer.style.gap = '10px';
        iconContainer.style.alignItems = 'center';

        // Checkmark icon
        const checkIcon = document.createElement('span');
        checkIcon.innerHTML = '✅';
        checkIcon.style.fontSize = '20px';
        checkIcon.style.cursor = 'help';
        checkIcon.title = `Accepted: ${reason || 'Connection confirmed'}`;

        // Open in new tab icon
        const openIcon = document.createElement('span');
        openIcon.innerHTML = '🔗';
        openIcon.style.fontSize = '20px';
        openIcon.style.cursor = 'pointer';
        openIcon.title = 'Open profile in new tab';

        // Find the profile link
        let profileUrl = '';
        const links = acceptedCard.querySelectorAll('a');
        for (const link of links) {
            if (link.href && link.href.includes('linkedin.com/in/')) {
                profileUrl = link.href;
                break;
            }
        }

        // Add click handler for opening in new tab
        if (profileUrl) {
            openIcon.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                openInBackgroundTab(profileUrl, name, 0); // Open immediately on click
            });
            
            // Automatically open profile in background tab
            openInBackgroundTab(profileUrl, name, index);
        } else {
            openIcon.style.opacity = '0.5';
            openIcon.title = 'Profile link not found';
            debugLog(`Could not find profile link for ${name}`, 'warning');
        }

        // Add icons to container
        iconContainer.appendChild(checkIcon);
        iconContainer.appendChild(openIcon);
        
        // Add container to card
        acceptedCard.appendChild(iconContainer);
        debugLog(`Highlighted post-accept invitation from ${name}`, 'success');
    });

    debugLog(`Found and highlighted ${foundCount} of ${acceptedInvitations.length} post-accept invitations.`, 'info');
    debugLog('Post-accept highlighting complete.', 'success');
}

// Listen for start message from popup
chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
    debugLog('Received message:', 'info');
    console.log(request);
    
    if (request.action === "startProcessing") {
        debugLog('Starting processing from message listener', 'info');
        startProcessing(request.criteria.batchLimit);
        // Send response back to indicate we received the message
        sendResponse({ status: 'started' });
    }
    // Required for async response
    return true;
});

// Main processing function
async function startProcessing(batchLimit) {
    debugLog('Starting invitation processing...', 'info');
    // Ensure the live log script is loaded
    await loadLiveLogScript();
    updateLiveLog("Starting invitation processing...", "processing");

    try {
        // Check if we're on the correct page
        if (!window.location.href.includes('linkedin.com/mynetwork/invitation-manager')) {
            debugLog('Not on the invitation manager page!', 'error');
            return;
        }

        debugLog('Starting script for next batch...', 'processing');
        debugLog(`Previously processed ${window.processedInvitations.size} invitations`, 'info');

        await scrollLikeHuman();
        debugLog('Scrolled page to load more invitations', 'info');

        const invitations = await extractLinkedInInvitations(batchLimit);
        const batchSize = Object.keys(invitations).length;

        if (batchSize === 0) {
            debugLog('No more unprocessed invitations found.', 'warning');
            return;
        }

        debugLog(`Processing next batch of ${batchSize} invitations...`, 'processing');
        await processInvitationsWithCriteria(invitations);
        debugLog('Batch processing complete.', 'success');
        debugLog(`Total processed so far: ${window.processedInvitations.size}`, 'info');

    } catch (error) {
        debugLog(`Error during invitation processing: ${error.message}`, 'error');
        console.error(error);
    }
}


function createStartButton() {
    // Check if button already exists
    if (document.getElementById('linkedInStartButton')) return;

    // Inject styles only once
    if (!document.getElementById('dynamic-comment-styles')) {
        const style = document.createElement('style');
        style.id = 'dynamic-comment-styles';
        style.textContent = `
            .dynamic-comment-buttons {
                border: none;
                border-radius: 12px;
                padding: 10px;
                margin: 16px;
                display: flex;
                flex-wrap: wrap;
                gap: 10px;
                box-shadow: 0 0 8px rgba(100, 149, 237, 0.2);
                overflow-x: auto;
                background: #ffffff;
                justify-content: flex-start;
            }
            .dynamic-comment-buttons, .comment-btn {
                box-sizing: border-box;
            }
            .comment-btn {
                position: relative;
                overflow: hidden;
                background: #ffffff;
                color: rgb(0, 51, 204);
                border: 1px solid rgb(0, 51, 204);
                padding: 5px 10px;
                border-radius: 50px;
                font-size: 14px;
                font-weight: normal;
                cursor: pointer;
                white-space: nowrap;
                flex-shrink: 0;
                min-width: unset;
                text-align: center;
                transition: all 0.4s ease;
            }
            .comment-btn:hover {
                background: rgb(0, 51, 204);
                color: #ffffff;
            }
            .comment-btn:active {
                transform: scale(0.98);
            }
            .comment-btn::after {
                content: '';
                position: absolute;
                top: var(--y);
                left: var(--x);
                width: 0;
                height: 0;
                background: rgba(255, 255, 255, 0.3);
                border-radius: 50%;
                transform: translate(-50%, -50%);
                opacity: 0;
            }
            .comment-btn.active::after {
                width: 200px;
                height: 200px;
                opacity: 1;
                transition: width 0.5s ease-out, height 0.5s ease-out, opacity 1s ease;
            }
            .comment-btn:disabled {
                opacity: 0.6;
                cursor: not-allowed;
                transform: none !important;
                background: #24268d;
                border: 1px solid #24268d;
                color: #ffffff;
            }
        `;
        document.head.appendChild(style);
    }
    

    // Create container
    const buttonContainer = document.createElement('div');
    buttonContainer.style.position = 'fixed';
    buttonContainer.style.top = '60px';
    buttonContainer.style.left = '360px';
    buttonContainer.style.zIndex = '9999';
    buttonContainer.style.cursor = 'move';
    buttonContainer.className = 'dynamic-comment-buttons';

    // Create the button
    const startButton = document.createElement('button');
    startButton.id = 'linkedInStartButton';
    startButton.className = 'comment-btn';
    startButton.innerText = 'Start Processing';

    

    // Drag functionality
    let isDragging = false;
    let currentX, currentY, initialX, initialY, xOffset = 0, yOffset = 0;

    buttonContainer.addEventListener('mousedown', dragStart);
    document.addEventListener('mousemove', drag);
    document.addEventListener('mouseup', dragEnd);

    function dragStart(e) {
        initialX = e.clientX - xOffset;
        initialY = e.clientY - yOffset;
        if (e.target === buttonContainer) {
            isDragging = true;
        }
    }

    function drag(e) {
        if (!isDragging) return;
        e.preventDefault();
        currentX = e.clientX - initialX;
        currentY = e.clientY - initialY;
        xOffset = currentX;
        yOffset = currentY;
        setTranslate(currentX, currentY, buttonContainer);
    }

    function dragEnd() {
        isDragging = false;
    }

    function setTranslate(xPos, yPos, el) {
        el.style.transform = `translate3d(${xPos}px, ${yPos}px, 0)`;
    }


    // Append button to container and container to body
    buttonContainer.appendChild(startButton);
    document.body.appendChild(buttonContainer);

    
    // Add hover effect
    startButton.onmouseover = function() {
        this.style.backgroundColor = '#005bb5';
    };
    startButton.onmouseout = function() {
        this.style.backgroundColor = '#0073e6';
    };
    
    // Add click event
    startButton.addEventListener('click', async function() {
        debugLog('Start button clicked', 'info');
        const criteria = await loadCriteria();
        startProcessing(criteria.batchLimit);
    });
    
    // Add button to container and container to page
    buttonContainer.appendChild(startButton);
    document.body.appendChild(buttonContainer);
    
    debugLog('Start Processing button added to page', 'success');
}

// Check if we're on the correct page and initialize
function initializeOnInvitationManager() {
    if (window.location.href.includes('linkedin.com/mynetwork/invitation-manager')) {
        debugLog('On invitation manager page, initializing...', 'info');
        createStartButton();
        
        // Also monitor for URL changes (in case user navigates to page after script loads)
        const observer = new MutationObserver(function(mutations) {
            if (window.location.href.includes('linkedin.com/mynetwork/invitation-manager')) {
                createStartButton();
            }
        });
        
        observer.observe(document, {subtree: true, childList: true});
    }
}



// Function to check if we're on the invitation manager page
function isInvitationManagerPage() {
    return window.location.href.includes('linkedin.com/mynetwork/invitation-manager');
}

// Function to remove all extension UI elements
function removeExtensionUI() {
    // Remove debug panel if exists
    const debugPanel = document.getElementById('debug-utils');
    if (debugPanel) debugPanel.remove();
    
    // Remove live log if exists
    const liveLog = document.getElementById('live-log-container');
    if (liveLog) liveLog.remove();
    
    // Remove invitation stats popup if exists
    const statsPopup = document.getElementById('invitation-stats-popup');
    if (statsPopup) statsPopup.remove();
    
    // Remove start button if exists
    const startButton = document.getElementById('linkedInStartButton');
    if (startButton) startButton.parentElement.remove();
}

// Function to handle page changes
function handlePageChange() {
    if (isInvitationManagerPage()) {
        // On invitation manager page - initialize UI
        createStartButton();
    } else {
        // On other pages - remove all extension UI
        removeExtensionUI();
    }
}

// Modified initialization function
function initializeOnInvitationManager() {
    // Initial check
    handlePageChange();
    
    // Monitor for URL changes
    let lastUrl = window.location.href;
    const observer = new MutationObserver(() => {
        if (window.location.href !== lastUrl) {
            lastUrl = window.location.href;
            handlePageChange();
        }
    });
    
    observer.observe(document, { subtree: true, childList: true });
}

// Call initialization when script loads
initializeOnInvitationManager();

// Function to process connections with a 50-second delay
async function processConnectionsWithDelay() {
    debugLog('Starting to process connections with 50-second delay...', 'processing');
    updateLiveLog("⏱️ Starting to process connections with 50-second delay...", "processing");
    
    // Find all accept buttons on the page
    const acceptButtons = Array.from(document.querySelectorAll('button[aria-label*="Accept"]'));
    
    if (acceptButtons.length === 0) {
        debugLog('No accept buttons found on the page.', 'warning');
        updateLiveLog("No accept buttons found on the page.", "error");
        return;
    }
    
    debugLog(`Found ${acceptButtons.length} accept buttons. Processing one by one with 50-second delay...`, 'info');
    updateLiveLog(`Found ${acceptButtons.length} accept buttons. Processing with 50-second delay...`, "processing");
    
    // Process each button with a 50-second delay
    let processedCount = 0;
    for (const button of acceptButtons) {
        const ariaLabel = button.getAttribute('aria-label') || '';
        const nameMatch = ariaLabel.match(/Accept\s(.+?)('s invitation)?$/);
        const name = nameMatch ? nameMatch[1] : 'Unknown';

        debugLog(`Processing connection request from: ${name}`, 'processing');
        updateLiveLog(`Processing connection for: ${name}`, "processing");

        try {
            button.scrollIntoView({ behavior: 'smooth', block: 'center' });

            await new Promise(resolve => setTimeout(resolve, 1000 + Math.random() * 500));
            button.click();
            processedCount++;

            window.invitationCounters.processed++;
            window.invitationCounters.accepted++;

            createOrUpdatePopup();
            debugLog(`Accepted connection from ${name} (${processedCount}/${acceptButtons.length})`, 'success');
            updateLiveLog(`✅ Accepted connection from ${name} (${processedCount}/${acceptButtons.length})`, "success");

            await new Promise(resolve => setTimeout(resolve, 50000)); // 50 sec delay

        } catch (error) {
            debugLog(`Error processing connection from ${name}: ${error.message}`, 'error');
            updateLiveLog(`❌ Error with ${name}: ${error.message}`, "error");
        }
    }
    
    debugLog(`Finished processing ${processedCount} connections.`, 'success');
    updateLiveLog(`✅ Finished processing ${processedCount} connections.`, "success");
}

// Create and add the "Start Accept" button
function createStartAcceptButton() {
    if (document.getElementById('startAcceptButton')) return;

    const buttonContainer = document.querySelector('.dynamic-comment-buttons') || document.createElement('div');
    buttonContainer.style.position = 'fixed';
    buttonContainer.style.top = '60px';
    buttonContainer.style.left = '400px';
    buttonContainer.style.zIndex = '9999';
    buttonContainer.style.cursor = 'move';
    buttonContainer.className = 'dynamic-comment-buttons';
    document.body.appendChild(buttonContainer);

    const startAcceptButton = document.createElement('button');
    startAcceptButton.id = 'startAcceptButton';
    startAcceptButton.innerText = 'Start Accept';
    startAcceptButton.style.cssText = `
        background-color: #0078d4;
        color: white;
        border: 1px solid #0078d4;
        border-radius: 4px;
        padding: 8px 16px;
        cursor: pointer;
        font-weight: bold;
    `;

    startAcceptButton.onmouseover = () => startAcceptButton.style.backgroundColor = '#005a9e';
    startAcceptButton.onmouseout = () => startAcceptButton.style.backgroundColor = '#0078d4';

    startAcceptButton.addEventListener('click', async function() {
        debugLog('Start Accept button clicked', 'info');
        this.disabled = true;
        this.innerText = 'Processing...';

        try {
            await processConnectionsWithDelay();
        } catch (error) {
            debugLog(`Error in processing: ${error.message}`, 'error');
        } finally {
            this.disabled = false;
            this.innerText = 'Start Accept';
        }
    });

    buttonContainer.appendChild(startAcceptButton);
}

// Initialize the modified button when the page loads
if (isInvitationManagerPage()) {
    createStartAcceptButton();
}

// Ensure the button is removed properly when UI changes
const originalRemoveExtensionUI = removeExtensionUI;
removeExtensionUI = function() {
    originalRemoveExtensionUI();
    
    const startAcceptButton = document.getElementById('startAcceptButton');
    if (startAcceptButton && startAcceptButton.parentElement) {
        startAcceptButton.parentElement.remove();
    }
};
